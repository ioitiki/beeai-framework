{"version":3,"sources":["in_memory_store.ts"],"names":["InMemoryEventStore","events","Map","generateEventId","streamId","Date","now","Math","random","toString","substring","getStreamIdFromEventId","eventId","parts","split","length","storeEvent","message","set","replayEventsAfter","lastEventId","send","has","foundLastEvent","sortedEvents","entries","sort","a","b","localeCompare","eventStreamId"],"mappings":";;;;AA0BO,MAAMA,kBAAAA,CAAAA;EA1Bb;;;AA2BUC,EAAAA,MAAAA,uBAAaC,GAAAA,EAAAA;;;;AAKbC,EAAAA,eAAAA,CAAgBC,QAA0B,EAAA;AAChD,IAAA,OAAO,GAAGA,QAAAA,CAAAA,CAAAA,EAAYC,IAAKC,CAAAA,GAAAA,EAAG,CAAMC,CAAAA,EAAAA,IAAAA,CAAKC,MAAM,EAAA,CAAGC,SAAS,EAAA,CAAA,CAAIC,SAAU,CAAA,CAAA,EAAG,EAAA,CAAA,CAAA,CAAA;AAC9E;;;;AAKQC,EAAAA,sBAAAA,CAAuBC,OAAyB,EAAA;AACtD,IAAMC,MAAAA,KAAAA,GAAQD,OAAQE,CAAAA,KAAAA,CAAM,GAAA,CAAA;AAC5B,IAAA,OAAOD,KAAME,CAAAA,MAAAA,GAAS,CAAIF,GAAAA,KAAAA,CAAM,CAAA,CAAK,GAAA,EAAA;AACvC;;;;;EAMA,MAAMG,UAAAA,CAAWZ,UAAkBa,OAA0C,EAAA;AAC3E,IAAML,MAAAA,OAAAA,GAAU,IAAKT,CAAAA,eAAAA,CAAgBC,QAAAA,CAAAA;AACrC,IAAKH,IAAAA,CAAAA,MAAAA,CAAOiB,IAAIN,OAAS,EAAA;AAAER,MAAAA,QAAAA;AAAUa,MAAAA;KAAQ,CAAA;AAC7C,IAAOL,OAAAA,OAAAA;AACT;;;;;AAMA,EAAA,MAAMO,iBACJC,CAAAA,WAAAA,EACA,EAAEC,IAAAA,EACe,EAAA;AACjB,IAAA,IAAI,CAACD,WAAe,IAAA,CAAC,KAAKnB,MAAOqB,CAAAA,GAAAA,CAAIF,WAAAA,CAAc,EAAA;AACjD,MAAO,OAAA,EAAA;AACT;AAGA,IAAMhB,MAAAA,QAAAA,GAAW,IAAKO,CAAAA,sBAAAA,CAAuBS,WAAAA,CAAAA;AAC7C,IAAA,IAAI,CAAChB,QAAU,EAAA;AACb,MAAO,OAAA,EAAA;AACT;AAEA,IAAA,IAAImB,cAAiB,GAAA,KAAA;AAGrB,IAAA,MAAMC,YAAe,GAAA;AAAI,MAAA,GAAA,IAAA,CAAKvB,OAAOwB,OAAO;MAAIC,IAAK,CAAA,CAACC,CAAGC,EAAAA,CAAAA,KAAMD,CAAE,CAAA,CAAA,EAAGE,aAAcD,CAAAA,CAAAA,CAAE,CAAA,CAAE,CAAA,CAAA;AAEtF,IAAW,KAAA,MAAA,CAAChB,SAAS,EAAER,QAAAA,EAAU0B,eAAeb,OAAO,EAAE,KAAKO,YAAc,EAAA;AAE1E,MAAA,IAAIM,kBAAkB1B,QAAU,EAAA;AAC9B,QAAA;AACF;AAGA,MAAA,IAAIQ,YAAYQ,WAAa,EAAA;AAC3BG,QAAiB,cAAA,GAAA,IAAA;AACjB,QAAA;AACF;AAEA,MAAA,IAAIA,cAAgB,EAAA;AAClB,QAAMF,MAAAA,IAAAA,CAAKT,SAASK,OAAAA,CAAAA;AACtB;AACF;AACA,IAAOb,OAAAA,QAAAA;AACT;AACF","file":"in_memory_store.cjs","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Taken from: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/examples/shared/inMemoryEventStore.ts\n\nimport { EventStore } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\n\n/**\n * Simple in-memory implementation of the EventStore interface for resumability\n * This is primarily intended for examples and testing, not for production use\n * where a persistent storage solution would be more appropriate.\n */\nexport class InMemoryEventStore implements EventStore {\n  private events = new Map<string, { streamId: string; message: JSONRPCMessage }>();\n\n  /**\n   * Generates a unique event ID for a given stream ID\n   */\n  private generateEventId(streamId: string): string {\n    return `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n  }\n\n  /**\n   * Extracts the stream ID from an event ID\n   */\n  private getStreamIdFromEventId(eventId: string): string {\n    const parts = eventId.split(\"_\");\n    return parts.length > 0 ? parts[0] : \"\";\n  }\n\n  /**\n   * Stores an event with a generated event ID\n   * Implements EventStore.storeEvent\n   */\n  async storeEvent(streamId: string, message: JSONRPCMessage): Promise<string> {\n    const eventId = this.generateEventId(streamId);\n    this.events.set(eventId, { streamId, message });\n    return eventId;\n  }\n\n  /**\n   * Replays events that occurred after a specific event ID\n   * Implements EventStore.replayEventsAfter\n   */\n  async replayEventsAfter(\n    lastEventId: string,\n    { send }: { send: (eventId: string, message: JSONRPCMessage) => Promise<void> },\n  ): Promise<string> {\n    if (!lastEventId || !this.events.has(lastEventId)) {\n      return \"\";\n    }\n\n    // Extract the stream ID from the event ID\n    const streamId = this.getStreamIdFromEventId(lastEventId);\n    if (!streamId) {\n      return \"\";\n    }\n\n    let foundLastEvent = false;\n\n    // Sort events by eventId for chronological ordering\n    const sortedEvents = [...this.events.entries()].sort((a, b) => a[0].localeCompare(b[0]));\n\n    for (const [eventId, { streamId: eventStreamId, message }] of sortedEvents) {\n      // Only include events from the same stream\n      if (eventStreamId !== streamId) {\n        continue;\n      }\n\n      // Start sending events after we find the lastEventId\n      if (eventId === lastEventId) {\n        foundLastEvent = true;\n        continue;\n      }\n\n      if (foundLastEvent) {\n        await send(eventId, message);\n      }\n    }\n    return streamId;\n  }\n}\n"]}