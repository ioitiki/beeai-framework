{"version":3,"sources":["utils.ts"],"names":["encodeCustomMessage","msg","UserMessage","type","text","role","content","slice","decodeCustomMessage","value","_","id","split","join","unmaskCustomMessage","Role","USER","key","Array","isArray","map","val","filter","isTruthy","decoded","vercelFetcher","customFetch","url","options","isString","body","getProp","headers","JSON","parse","isPlainObject","messages","forEach","stringify","fetcher","fetch"],"mappings":"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","file":"utils.cjs","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CustomMessage, Role, UserMessage } from \"@/backend/message.js\";\nimport { isPlainObject, isString, isTruthy } from \"remeda\";\nimport { getProp } from \"@/internals/helpers/object.js\";\nimport { TextPart } from \"ai\";\n\nexport function encodeCustomMessage(msg: CustomMessage): UserMessage {\n  return new UserMessage([\n    {\n      type: \"text\",\n      text: `#custom_role#${msg.role}#`,\n    },\n    ...(msg.content.slice() as TextPart[]),\n  ]);\n}\n\nexport function decodeCustomMessage(value: string) {\n  const [_, id, role, ...content] = value.split(\"#\");\n  if (id !== \"custom_role\") {\n    return;\n  }\n  return { role, content: content.join(\"#\") };\n}\n\nfunction unmaskCustomMessage(msg: Record<string, any>) {\n  if (msg.role !== Role.USER) {\n    return;\n  }\n\n  for (const key of [\"content\", \"text\"]) {\n    let value = msg[key];\n    if (!value) {\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      value = value\n        .map((val) => (val.type === \"text\" ? val.text || val.content : null))\n        .filter(isTruthy)\n        .join(\"\");\n    }\n\n    const decoded = decodeCustomMessage(value);\n    if (decoded) {\n      msg.role = decoded.role;\n      msg[key] = decoded.content;\n      break;\n    }\n  }\n}\n\nexport function vercelFetcher(customFetch?: typeof fetch): typeof fetch {\n  return async (url, options) => {\n    if (\n      options &&\n      isString(options.body) &&\n      (getProp(options.headers, [\"content-type\"]) == \"application/json\" ||\n        getProp(options.headers, [\"Content-Type\"]) == \"application/json\")\n    ) {\n      const body = JSON.parse(options.body);\n      if (isPlainObject(body) && Array.isArray(body.messages)) {\n        body.messages.forEach((msg) => {\n          if (!isPlainObject(msg)) {\n            return;\n          }\n          unmaskCustomMessage(msg);\n        });\n      }\n      options.body = JSON.stringify(body);\n    }\n\n    const fetcher = customFetch ?? fetch;\n    return await fetcher(url, options);\n  };\n}\n"]}