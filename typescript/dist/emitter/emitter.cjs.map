{"version":3,"sources":["emitter.ts"],"names":["Emitter","Serializable","listeners","Set","groupId","namespace","creator","context","trace","cleanups","constructor","input","Object","prototype","assertValidNamespace","register","root","create","child","slice","cleanup","pipe","push","target","on","toBoundedFunction","args","invoke","value","name","isBlocking","once","persistent","destroy","clear","forEach","length","reset","listener","options","delete","registerCallbacks","callbacks","entries","key","event","callback","match","matcher","createMatcher","matchers","matchNested","path","createFullPath","RegExp","test","isPath","EmitterError","matchSameRun","runId","unshift","every","raw","add","emit","assertValidName","createEvent","data","executions","values","run","Promise","all","id","createRandomHash","createdAt","Date","source","assign","shallowCopy","createSnapshot","Array","from","map","pick","loadSnapshot","snapshot"],"mappings":"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","file":"emitter.cjs","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Callback,\n  CleanupFn,\n  EmitterOptions,\n  EventMeta,\n  EventTrace,\n  Matcher,\n  MatcherFn,\n  StringKey,\n} from \"@/emitter/types.js\";\nexport type { EventMeta, EventTrace, Callback };\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { createFullPath, isPath, assertValidName, assertValidNamespace } from \"@/emitter/utils.js\";\nimport { EmitterError } from \"@/emitter/errors.js\";\nimport { createRandomHash } from \"@/internals/helpers/hash.js\";\nimport { shallowCopy, toBoundedFunction } from \"@/serializer/utils.js\";\nimport { RequiredAll } from \"@/internals/types.js\";\nimport { Serializable } from \"@/internals/serializable.js\";\nimport { pick } from \"remeda\";\n\nexport interface EmitterInput<E extends object = object> {\n  groupId?: string;\n  namespace?: string[];\n  creator?: object;\n  context?: E & object;\n  trace?: EventTrace;\n}\nexport interface EmitterChildInput<E extends object = object> {\n  groupId?: string;\n  namespace?: string[];\n  creator?: object;\n  context?: E & object;\n  trace?: EventTrace;\n}\n\ninterface Listener<T = any> {\n  readonly match: MatcherFn;\n  readonly raw: Matcher;\n  readonly callback: Callback<T>;\n  readonly options?: EmitterOptions;\n}\n\nexport class Emitter<T = Record<keyof any, Callback<unknown>>> extends Serializable {\n  protected listeners = new Set<Listener>();\n  protected readonly groupId?: string;\n  public readonly namespace: string[];\n  public readonly creator?: object;\n  public readonly context: object;\n  public readonly trace?: EventTrace;\n  protected readonly cleanups: CleanupFn[] = [];\n\n  constructor(input: EmitterInput = {}) {\n    super();\n    this.groupId = input?.groupId;\n    this.namespace = input?.namespace ?? [];\n    this.creator = input.creator ?? Object.prototype;\n    this.context = input?.context ?? {};\n    this.trace = input.trace;\n    assertValidNamespace(this.namespace);\n  }\n\n  static {\n    this.register();\n  }\n\n  @Cache()\n  static get root() {\n    return new Emitter<Record<string, Callback<any>>>({ creator: Object.create(null) });\n  }\n\n  child<R = T>(input: EmitterChildInput = {}): Emitter<R> {\n    const child = new Emitter<R>({\n      trace: input.trace ?? this.trace,\n      groupId: input?.groupId ?? this.groupId,\n      context: { ...this.context, ...input?.context },\n      creator: input?.creator ?? this.creator,\n      namespace: input?.namespace\n        ? [...this.namespace, ...input.namespace]\n        : this.namespace.slice(),\n    });\n\n    const cleanup = child.pipe(this);\n    this.cleanups.push(cleanup);\n\n    return child;\n  }\n\n  pipe(target: Emitter<any>): CleanupFn {\n    return this.on(\n      // @ts-expect-error\n      \"*.*\",\n      toBoundedFunction(\n        // @ts-expect-error\n        (...args) => target.invoke(...args),\n        [{ value: target, name: \"target\" }],\n      ),\n      {\n        isBlocking: true,\n        once: false,\n        persistent: true,\n      },\n    );\n  }\n\n  destroy() {\n    this.listeners.clear();\n    this.cleanups.forEach((child) => child());\n    this.cleanups.length = 0;\n  }\n\n  reset() {\n    for (const listener of this.listeners) {\n      if (!listener.options?.persistent) {\n        this.listeners.delete(listener);\n      }\n    }\n  }\n\n  registerCallbacks<K extends StringKey<RequiredAll<T>>>(\n    callbacks: Partial<\n      Record<K, NonNullable<T[K]> extends Callback<infer X> ? Callback<X> : never>\n    >,\n    options?: Partial<Record<K, EmitterOptions>>,\n  ): CleanupFn {\n    const listeners: CleanupFn[] = [];\n    Object.entries(callbacks).forEach(([key, value]) => {\n      if (value) {\n        // @ts-expect-error\n        listeners.push(this.on(key, value, options?.[key]));\n      }\n    });\n    return () => listeners.forEach((cleanup) => cleanup());\n  }\n\n  on<K extends StringKey<RequiredAll<T>>>(\n    event: K,\n    callback: NonNullable<T[K]> extends Callback<any> ? T[K] : never,\n    options?: EmitterOptions,\n  ): CleanupFn {\n    return this.match(event as Matcher, callback as Callback<any>, options);\n  }\n\n  match<L>(matcher: Matcher, callback: Callback<L>, options?: EmitterOptions): CleanupFn {\n    const createMatcher = (): MatcherFn => {\n      const matchers: MatcherFn[] = [];\n      let matchNested = options?.matchNested;\n\n      if (matcher === \"*\") {\n        matchNested ??= false;\n        matchers.push((event) => event.path === createFullPath(this.namespace, event.name));\n      } else if (matcher === \"*.*\") {\n        matchNested ??= true;\n        matchers.push(() => true);\n      } else if (matcher instanceof RegExp) {\n        matchNested ??= true;\n        matchers.push((event) => matcher.test(event.path));\n      } else if (typeof matcher === \"function\") {\n        matchNested ??= false;\n        matchers.push(matcher);\n      } else if (typeof matcher === \"string\") {\n        if (isPath(matcher)) {\n          matchNested ??= true;\n          matchers.push((event) => event.path === matcher);\n        } else {\n          matchNested ??= false;\n          matchers.push(\n            (event) =>\n              event.name === matcher && event.path === createFullPath(this.namespace, event.name),\n          );\n        }\n      } else {\n        throw new EmitterError(\"Invalid matcher provided!\");\n      }\n\n      if (!matchNested) {\n        const matchSameRun = (event: EventMeta) => {\n          // global observability x scoped observability\n          return !this.trace?.runId ? true : this.trace?.runId === event.trace?.runId;\n        };\n        matchers.unshift(matchSameRun);\n      }\n\n      return (event) => matchers.every((matcher) => matcher(event));\n    };\n\n    const listener: Listener = {\n      options,\n      callback,\n      raw: matcher,\n      match: createMatcher(),\n    };\n    this.listeners.add(listener);\n\n    return () => this.listeners.delete(listener);\n  }\n\n  async emit<K extends StringKey<RequiredAll<T>>>(\n    name: K,\n    value: NonNullable<T[K]> extends Callback<infer X> ? X : unknown,\n  ): Promise<void> {\n    assertValidName(name);\n\n    const event = this.createEvent(name);\n    return await this.invoke(value, event);\n  }\n\n  protected async invoke(data: unknown, event: EventMeta) {\n    const executions: unknown[] = [];\n    for (const listener of this.listeners.values()) {\n      if (!listener.match(event)) {\n        continue;\n      }\n\n      if (listener.options?.once) {\n        this.listeners.delete(listener);\n      }\n\n      const run = async () => listener.callback(data, event);\n      executions.push(listener.options?.isBlocking ? await run() : run());\n    }\n    await Promise.all(executions);\n  }\n\n  protected createEvent(name: string): EventMeta {\n    return {\n      id: createRandomHash(),\n      groupId: this.groupId,\n      name,\n      path: createFullPath(this.namespace, name),\n      createdAt: new Date(),\n      source: this,\n      creator: this.creator!,\n      context: Object.assign({}, this.context, {}),\n      trace: shallowCopy(this.trace), // TODO\n    };\n  }\n\n  createSnapshot() {\n    return {\n      groupId: this.groupId,\n      namespace: shallowCopy(this.namespace),\n      creator: this.creator,\n      context: this.context,\n      trace: this.trace,\n      listeners: Array.from(this.listeners).map(pick([\"raw\", \"options\", \"callback\"])),\n      cleanups: this.cleanups,\n    };\n  }\n\n  loadSnapshot({ listeners, ...snapshot }: ReturnType<typeof this.createSnapshot>): void {\n    Object.assign(this, snapshot, { listeners: new Set() });\n    listeners.forEach(({ raw, callback, options }) => this.match(raw, callback, options));\n  }\n}\n"]}