{"version":3,"sources":["tokenMemory.ts"],"names":["simpleEstimate","msg","Math","ceil","text","length","simpleTokenize","msgs","sum","map","TokenMemory","BaseMemory","messages","threshold","syncThreshold","maxTokens","tokensByMessage","WeakMap","handlers","constructor","config","capacityThreshold","estimate","role","tokenize","removalSelector","R","clamp","min","max","TypeError","register","tokensUsed","get","tokensCount","isDirty","some","dirty","add","message","index","meta","has","MemoryFatalError","messageToDelete","exists","delete","set","ensureRange","splice","sync","removeFromArray","Promise","all","cache","addMany","reset","stats","messagesCount","createSnapshot","shallowCopy","filter","_","value","undefined","loadSnapshot","state","Object","assign"],"mappings":"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","file":"tokenMemory.cjs","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BaseMemory, MemoryFatalError } from \"@/memory/base.js\";\nimport * as R from \"remeda\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\nimport { removeFromArray } from \"@/internals/helpers/array.js\";\nimport { map, sum } from \"remeda\";\nimport { ensureRange } from \"@/internals/helpers/number.js\";\nimport { Message } from \"@/backend/message.js\";\n\nexport interface Handlers {\n  estimate: (messages: Message) => number;\n  tokenize: (messages: Message[]) => Promise<number>;\n  removalSelector: (messages: Message[]) => Message;\n}\n\nconst simpleEstimate: Handlers[\"estimate\"] = (msg: Message) => Math.ceil(msg.text.length / 4);\nconst simpleTokenize: Handlers[\"tokenize\"] = async (msgs: Message[]) =>\n  sum(map(msgs, simpleEstimate)); // TODO\n\nexport interface TokenMemoryInput {\n  maxTokens?: number;\n  syncThreshold?: number;\n  capacityThreshold?: number;\n  handlers?: Partial<Handlers>;\n}\n\ninterface TokenByMessage {\n  tokensCount: number;\n  dirty: boolean;\n}\n\nexport class TokenMemory extends BaseMemory {\n  public readonly messages: Message[] = [];\n\n  protected threshold;\n  protected syncThreshold;\n  protected maxTokens: number | null = null;\n  protected tokensByMessage = new WeakMap<Message, TokenByMessage>();\n  public readonly handlers: Handlers;\n\n  constructor(config: TokenMemoryInput = {}) {\n    super();\n    this.maxTokens = config.maxTokens ?? null;\n    this.threshold = config.capacityThreshold ?? 0.75;\n    this.syncThreshold = config.syncThreshold ?? 0.25;\n    this.handlers = {\n      ...config?.handlers,\n      estimate:\n        config?.handlers?.estimate || ((msg) => Math.ceil((msg.role.length + msg.text.length) / 4)),\n      tokenize: config?.handlers?.tokenize || simpleTokenize,\n      removalSelector: config.handlers?.removalSelector || ((messages) => messages[0]),\n    };\n    if (!R.clamp({ min: 0, max: 1 })(this.threshold)) {\n      throw new TypeError('\"capacityThreshold\" must be a number in range (0, 1>');\n    }\n  }\n\n  static {\n    this.register();\n  }\n\n  get tokensUsed(): number {\n    return sum(this.messages.map((msg) => this.tokensByMessage.get(msg)!.tokensCount!));\n  }\n\n  get isDirty(): boolean {\n    return this.messages.some((msg) => this.tokensByMessage.get(msg)?.dirty !== false);\n  }\n\n  async add(message: Message, index?: number) {\n    if (this.maxTokens === null) {\n      // TODO: improve\n      this.maxTokens = 128_000;\n    }\n\n    const meta = this.tokensByMessage.has(message)\n      ? this.tokensByMessage.get(message)!\n      : { tokensCount: this.handlers.estimate(message), dirty: true };\n\n    if (meta.tokensCount > this.maxTokens) {\n      throw new MemoryFatalError(\n        `Retrieved message (${meta.tokensCount} tokens) cannot fit inside current memory (${this.maxTokens} tokens)`,\n      );\n    }\n\n    while (this.tokensUsed > this.maxTokens - meta.tokensCount) {\n      const messageToDelete = this.handlers.removalSelector(this.messages);\n      const exists = await this.delete(messageToDelete);\n\n      if (!messageToDelete || !exists) {\n        throw new MemoryFatalError('The \"removalSelector\" handler must return a valid message!');\n      }\n    }\n\n    this.tokensByMessage.set(message, meta);\n\n    index = ensureRange(index ?? this.messages.length, { min: 0, max: this.messages.length });\n    this.messages.splice(index, 0, message);\n\n    if (this.isDirty && this.tokensUsed / this.maxTokens >= this.syncThreshold) {\n      await this.sync();\n    }\n  }\n\n  async delete(message: Message) {\n    return removeFromArray(this.messages, message);\n  }\n\n  async sync() {\n    const messages = await Promise.all(\n      this.messages.map(async (msg) => {\n        const cache = this.tokensByMessage.get(msg);\n        if (cache?.dirty !== false) {\n          const tokensCount = await this.handlers.tokenize([msg]);\n          this.tokensByMessage.set(msg, { tokensCount, dirty: false });\n        }\n        return msg;\n      }),\n    );\n\n    this.messages.length = 0;\n    await this.addMany(messages);\n  }\n\n  reset() {\n    for (const msg of this.messages) {\n      this.tokensByMessage.delete(msg);\n    }\n    this.messages.length = 0;\n  }\n\n  stats() {\n    return {\n      tokensUsed: this.tokensUsed,\n      maxTokens: this.maxTokens,\n      messagesCount: this.messages.length,\n      isDirty: this.isDirty,\n    };\n  }\n\n  createSnapshot() {\n    return {\n      threshold: this.threshold,\n      syncThreshold: this.syncThreshold,\n      messages: shallowCopy(this.messages),\n      handlers: shallowCopy(this.handlers),\n      maxTokens: this.maxTokens,\n      tokensByMessage: this.messages\n        .map((message) => [message, this.tokensByMessage.get(message)])\n        .filter(([_, value]) => value !== undefined) as [Message, number][],\n    };\n  }\n\n  loadSnapshot({ tokensByMessage, ...state }: ReturnType<typeof this.createSnapshot>) {\n    Object.assign(this, state, {\n      tokensByMessage: new WeakMap(tokensByMessage),\n    });\n  }\n}\n"]}