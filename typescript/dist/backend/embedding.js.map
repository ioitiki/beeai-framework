{"version":3,"sources":["embedding.ts"],"names":["EmbeddingModel","Serializable","create","input","shallowCopy","RunContext","enter","params","signal","abortSignal","run","emitter","emit","result","pRetry","_create","retries","maxRetries","value","error","EmbeddingModelError","fromName","name","providerId","modelId","parseModel","Target","loadModel","createSnapshot","destroy"],"mappings":";;;;;;;;;AAkDO,MAAeA,uBAAuBC,YAAAA,CAAAA;EAlD7C;;;AAwDEC,EAAAA,MAAAA,CAAOC,KAA4B,EAAA;AACjCA,IAAAA,KAAAA,GAAQC,YAAYD,KAAAA,CAAAA;AAEpB,IAAOE,OAAAA,UAAAA,CAAWC,MAChB,IACA,EAAA;MAAEC,MAAQ,EAAA;AAACJ,QAAAA;;AAAiBK,MAAAA,MAAAA,EAAQL,KAAOM,EAAAA;AAAY,KAAA,EACvD,OAAOC,GAAAA,KAAAA;AACL,MAAI,IAAA;AACF,QAAMA,MAAAA,GAAAA,CAAIC,OAAQC,CAAAA,IAAAA,CAAK,OAAS,EAAA;AAAET,UAAAA;SAAM,CAAA;AACxC,QAAMU,MAAAA,MAAAA,GAA+B,MAAMC,MAAO,CAAA,MAAM,KAAKC,OAAQZ,CAAAA,KAAAA,EAAOO,GAAAA,CAAM,EAAA;AAChFM,UAAAA,OAAAA,EAASb,MAAMc,UAAc,IAAA,CAAA;AAC7BT,UAAAA,MAAAA,EAAQE,GAAIF,CAAAA;SACd,CAAA;AACA,QAAME,MAAAA,GAAAA,CAAIC,OAAQC,CAAAA,IAAAA,CAAK,SAAW,EAAA;UAAEM,KAAOL,EAAAA;SAAO,CAAA;AAClD,QAAOA,OAAAA,MAAAA;AACT,OAAA,CAAA,OAASM,KAAO,EAAA;AACd,QAAMT,MAAAA,GAAAA,CAAIC,OAAQC,CAAAA,IAAAA,CAAK,OAAS,EAAA;AAAET,UAAAA,KAAAA;AAAOgB,UAAAA;SAAM,CAAA;AAC/C,QAAA,IAAIA,iBAAiBC,mBAAqB,EAAA;AACxC,UAAMD,MAAAA,KAAAA;SACD,MAAA;AACL,UAAM,MAAA,IAAIC,oBAAoB,CAAiD,6CAAA,CAAA,EAAA;AAACD,YAAAA;AAAM,WAAA,CAAA;AACxF;OACF,SAAA;AACE,QAAA,MAAMT,GAAIC,CAAAA,OAAAA,CAAQC,IAAK,CAAA,QAAA,EAAU,IAAA,CAAA;AACnC;KACF,CAAA;AAEJ;AAEA,EAAA,aAAaS,SAASC,IAAoC,EAAA;AACxD,IAAA,MAAM,EAAEC,UAAYC,EAAAA,OAAAA,GAAU,EAAE,EAAA,GAAKC,WAAWH,IAAAA,CAAAA;AAChD,IAAA,MAAMI,MAAS,GAAA,MAAMC,SAA0BJ,CAAAA,UAAAA,EAAY,WAAA,CAAA;AAC3D,IAAO,OAAA,IAAIG,OAAOF,OAAAA,CAAAA;AACpB;EAOAI,cAAiB,GAAA;AACf,IAAO,OAAA;AAAEjB,MAAAA,OAAAA,EAAS,IAAKA,CAAAA;AAAQ,KAAA;AACjC;EAEAkB,OAAU,GAAA;AACR,IAAA,IAAA,CAAKlB,QAAQkB,OAAO,EAAA;AACtB;AACF","file":"embedding.js","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Serializable } from \"@/internals/serializable.js\";\nimport { Callback } from \"@/emitter/types.js\";\nimport { FrameworkError } from \"@/errors.js\";\nimport { Emitter } from \"@/emitter/emitter.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\nimport { GetRunContext, RunContext } from \"@/context.js\";\nimport { pRetry } from \"@/internals/helpers/retry.js\";\nimport { FullModelName, loadModel, parseModel } from \"@/backend/utils.js\";\nimport { ProviderName } from \"@/backend/constants.js\";\nimport { EmbeddingModelError } from \"@/backend/errors.js\";\n\nexport interface EmbeddingModelInput {\n  values: string[];\n  abortSignal?: AbortSignal;\n  maxRetries?: number;\n}\n\nexport interface EmbeddingModelOutput {\n  values: string[];\n  embeddings: number[][];\n  usage: { tokens?: number };\n}\n\nexport interface EmbeddingModelEvents {\n  success?: Callback<{ value: EmbeddingModelOutput }>;\n  start?: Callback<{ input: EmbeddingModelInput }>;\n  error?: Callback<{ input: EmbeddingModelInput; error: FrameworkError }>;\n  finish?: Callback<null>;\n}\n\nexport type EmbeddingModelEmitter<A = Record<never, never>> = Emitter<\n  EmbeddingModelEvents & Omit<A, keyof EmbeddingModelEvents>\n>;\n\nexport abstract class EmbeddingModel extends Serializable {\n  public abstract readonly emitter: Emitter<EmbeddingModelEvents>;\n\n  abstract get modelId(): string;\n  abstract get providerId(): string;\n\n  create(input: EmbeddingModelInput) {\n    input = shallowCopy(input);\n\n    return RunContext.enter(\n      this,\n      { params: [input] as const, signal: input?.abortSignal },\n      async (run) => {\n        try {\n          await run.emitter.emit(\"start\", { input });\n          const result: EmbeddingModelOutput = await pRetry(() => this._create(input, run), {\n            retries: input.maxRetries || 0,\n            signal: run.signal,\n          });\n          await run.emitter.emit(\"success\", { value: result });\n          return result;\n        } catch (error) {\n          await run.emitter.emit(\"error\", { input, error });\n          if (error instanceof EmbeddingModelError) {\n            throw error;\n          } else {\n            throw new EmbeddingModelError(`The Embedding Model has encountered an error.`, [error]);\n          }\n        } finally {\n          await run.emitter.emit(\"finish\", null);\n        }\n      },\n    );\n  }\n\n  static async fromName(name: FullModelName | ProviderName) {\n    const { providerId, modelId = \"\" } = parseModel(name);\n    const Target = await loadModel<EmbeddingModel>(providerId, \"embedding\");\n    return new Target(modelId);\n  }\n\n  protected abstract _create(\n    input: EmbeddingModelInput,\n    run: GetRunContext<typeof this>,\n  ): Promise<EmbeddingModelOutput>;\n\n  createSnapshot() {\n    return { emitter: this.emitter };\n  }\n\n  destroy() {\n    this.emitter.destroy();\n  }\n}\n"]}