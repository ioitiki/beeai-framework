{"version":3,"sources":["fetcher.ts"],"names":["RestfulClientError","FrameworkError","createURLParams","data","urlTokenParams","URLSearchParams","key","value","Object","entries","undefined","Array","isArray","forEach","v","append","String","isPlainObject","set","toString","RestfulClient","Serializable","emitter","constructor","input","Emitter","root","child","namespace","creator","stream","path","init","groupId","url","getUrl","options","method","headers","getHeaders","emit","emitterToGenerator","fetchEventSource","onopen","response","contentType","get","ok","includes","EventStreamContentType","context","err","text","isRetryable","status","onmessage","msg","event","onclose","onerror","then","catch","error","doNothing","finally","fetch","target","searchParams","json","extra","final","override","filter","isTruthy","Headers","assign","fromEntries","URL","baseUrl","extraPath","paths","pathname","endsWith","replace","createSnapshot","shallowCopy","loadSnapshot","snapshot"],"mappings":";;;;;;;;;;AA6BO,MAAMA,2BAA2BC,cAAAA,CAAAA;EA7BxC;;;AA6BwD;AAGjD,SAASC,gBACdC,IAAyE,EAAA;AAEzE,EAAMC,MAAAA,cAAAA,GAAiB,IAAIC,eAAAA,EAAAA;AAC3B,EAAA,KAAA,MAAW,CAACC,GAAKC,EAAAA,KAAAA,KAAUC,MAAOC,CAAAA,OAAAA,CAAQN,IAAAA,CAAO,EAAA;AAC/C,IAAA,IAAII,UAAUG,MAAW,EAAA;AACvB,MAAA;AACF;AAEA,IAAIC,IAAAA,KAAAA,CAAMC,OAAQL,CAAAA,KAAAA,CAAQ,EAAA;AACxBA,MAAMM,KAAAA,CAAAA,OAAAA,CAAQ,CAACC,CAAAA,KAAAA;AACb,QAAA,IAAIA,MAAMJ,MAAW,EAAA;AACnBN,UAAAA,cAAAA,CAAeW,MAAOT,CAAAA,GAAAA,EAAKU,MAAOF,CAAAA,CAAAA,CAAAA,CAAAA;AACpC;OACF,CAAA;KACSG,MAAAA,IAAAA,aAAAA,CAAcV,KAAAA,CAAQ,EAAA;AAC/BH,MAAAA,cAAAA,CAAec,IAAIZ,GAAKJ,EAAAA,eAAAA,CAAgBK,KAAAA,CAAAA,CAAOY,UAAQ,CAAA;KAClD,MAAA;AACLf,MAAAA,cAAAA,CAAec,GAAIZ,CAAAA,GAAAA,EAAKU,MAAOT,CAAAA,KAAAA,CAAAA,CAAAA;AACjC;AACF;AACA,EAAOH,OAAAA,cAAAA;AACT;AAtBgBF,MAAAA,CAAAA,eAAAA,EAAAA,iBAAAA,CAAAA;AAgDT,MAAMkB,sBAAwDC,YAAAA,CAAAA;EAhFrE;;;;AAiFkBC,EAAAA,OAAAA;AAKhBC,EAAAA,WAAAA,CACYC,KAKV,EAAA;AACA,IAAK,KAAA,EAAA,EAAA,KANKA,KAAAA,GAAAA,KAAAA,EAAAA,KANIF,OAAUG,GAAAA,OAAAA,CAAQC,KAAKC,KAA2B,CAAA;MAChEC,SAAW,EAAA;AAAC,QAAA,WAAA;AAAa,QAAA;;MACzBC,OAAS,EAAA;KACX,CAAA;AAUA;EAEA,OAAOC,MAAAA,CACLC,MACAC,IACgD,EAAA;AAChD,IAAMV,MAAAA,OAAAA,GAAU,IAAKA,CAAAA,OAAAA,CAAQK,KAAM,CAAA;MACjCM,OAAS,EAAA;KACX,CAAA;AAEA,IAAA,MAAMT,KAAqB,GAAA;AACzBU,MAAAA,GAAAA,EAAK,IAAKC,CAAAA,MAAAA,CAAOJ,IAAAA,CAAAA,CAAMZ,QAAQ,EAAA;MAC/BiB,OAAS,EAAA;QACPC,MAAQ,EAAA,MAAA;QACR,GAAGL,IAAAA;AACHM,QAAAA,OAAAA,EAAS,MAAM,IAAA,CAAKC,UAAWP,CAAAA,IAAAA,EAAMM,OAAAA;AACvC;AACF,KAAA;AACA,IAAMhB,MAAAA,OAAAA,CAAQkB,KAAK,aAAe,EAAA;AAAEhB,MAAAA;KAAM,CAAA;AAE1C,IAAO,OAAA,OAAOiB,mBAAmB,OAAO,EAAED,MACxCE,KAAAA,gBAAAA,CAAiBlB,MAAMU,GAAK,EAAA;AAC1B,MAAA,GAAGV,KAAMY,CAAAA,OAAAA;AACT,MAAA,MAAMO,OAAOC,QAAQ,EAAA;AACnB,QAAA,MAAMC,WAAcD,GAAAA,QAAAA,CAASN,OAAQQ,CAAAA,GAAAA,CAAI,cAAA,CAAmB,IAAA,EAAA;AAC5D,QAAA,IAAIF,QAASG,CAAAA,EAAAA,IAAMF,WAAYG,CAAAA,QAAAA,CAASC,sBAAAA,CAAyB,EAAA;AAC/D,UAAM3B,MAAAA,OAAAA,CAAQkB,KAAK,YAAc,EAAA;AAAEhB,YAAAA;WAAM,CAAA;AACzC,UAAA;AACF;AACA,QAAA,MAAM,IAAIxB,kBAAAA,CAAmB,mBAAqB,EAAA,EAAI,EAAA;UACpDkD,OAAS,EAAA;AACPhB,YAAAA,GAAAA,EAAKU,QAASV,CAAAA,GAAAA;YACdiB,GAAK,EAAA,MAAMP,SAASQ,IAAI,EAAA;AACxBR,YAAAA;AACF,WAAA;AACAS,UAAAA,WAAAA,EAAaT,SAASU,MAAU,IAAA,GAAA,IAAOV,SAASU,MAAS,GAAA,GAAA,IAAOV,SAASU,MAAW,KAAA;SACtF,CAAA;AACF,OAAA;AACA,MAAA,MAAMC,UAAUC,GAAG,EAAA;AACjB,QAAIA,IAAAA,GAAAA,EAAKC,UAAU,OAAS,EAAA;AAC1B,UAAA,MAAM,IAAIzD,kBAAAA,CAAmB,CAAwC,oCAAA,CAAA,EAAA,EAAI,EAAA;YACvEkD,OAASM,EAAAA;WACX,CAAA;AACF;AACA,QAAMlC,MAAAA,OAAAA,CAAQkB,KAAK,eAAiB,EAAA;AAAEhB,UAAAA,KAAAA;UAAOrB,IAAMqD,EAAAA;SAAI,CAAA;AACvDhB,QAAAA,IAAAA,CAAKgB,GAAAA,CAAAA;AACP,OAAA;MACAE,OAAAA,GAAAA;AAAW,OAAA;AACXC,MAAAA,OAAAA,CAAQR,GAAG,EAAA;AACT,QAAM,MAAA,IAAInD,mBAAmB,CAAwC,oCAAA,CAAA,EAAA;AAACmD,UAAAA;AAAI,SAAA,CAAA;AAC5E;AACF,KAAA,CACGS,CAAAA,IAAAA,CAAK,MAAMtC,OAAAA,CAAQkB,KAAK,eAAiB,EAAA;AAAEhB,MAAAA;AAAM,KAAA,CAAA,CAAA,CACjDqC,KAAM,CAAA,OAAOC,KAAAA,KAAAA;AACZ,MAAMxC,MAAAA,OAAAA,CAAQkB,KAAK,aAAe,EAAA;AAAEhB,QAAAA,KAAAA;AAAOsC,QAAAA;OAAM,CAAA,CAAGD,KAAME,CAAAA,SAAAA,EAAAA,CAAAA;AAC1D,MAAMD,MAAAA,KAAAA;AACR,KAAA,CACCE,CAAAA,OAAAA,CAAQ,MAAM1C,OAAAA,CAAQkB,KAAK,YAAc,EAAA;AAAEhB,MAAAA;AAAM,KAAA,CAAA,CAAA,CAAA;AAExD;EAEA,MAAMyC,KAAAA,CAAMlC,MAAeC,IAAyD,EAAA;AAClF,IAAMV,MAAAA,OAAAA,GAAU,IAAKA,CAAAA,OAAAA,CAAQK,KAAM,CAAA;MACjCM,OAAS,EAAA;KACX,CAAA;AAEA,IAAMiC,MAAAA,MAAAA,GAAS,IAAK/B,CAAAA,MAAAA,CAAOJ,IAAAA,CAAAA;AAC3B,IAAA,IAAIC,MAAMmC,YAAc,EAAA;AACtB,MAAA,KAAA,MAAW,CAAC7D,GAAAA,EAAKC,KAAAA,CAAAA,IAAUyB,KAAKmC,YAAc,EAAA;AAC5CD,QAAOC,MAAAA,CAAAA,YAAAA,CAAajD,GAAIZ,CAAAA,GAAAA,EAAKC,KAAAA,CAAAA;AAC/B;AACF;AAEA,IAAA,MAAMiB,KAAoB,GAAA;AACxBU,MAAAA,GAAAA,EAAKgC,OAAO/C,QAAQ,EAAA;MACpBiB,OAAS,EAAA;QACP,GAAGJ,IAAAA;AACHM,QAAAA,OAAAA,EAAS,MAAM,IAAA,CAAKC,UAAWP,CAAAA,IAAAA,EAAMM,OAAAA;AACvC;AACF,KAAA;AAEA,IAAMhB,MAAAA,OAAAA,CAAQkB,KAAK,YAAc,EAAA;AAAEhB,MAAAA;KAAM,CAAA;AACzC,IAAI,IAAA;AACF,MAAA,MAAMoB,WAAW,MAAMqB,KAAAA,CAAMzC,KAAMU,CAAAA,GAAAA,EAAKV,MAAMY,OAAO,CAAA;AAErD,MAAI,IAAA,CAACQ,SAASG,EAAI,EAAA;AAChB,QAAA,MAAM,IAAI/C,kBAAAA,CAAmB,kBAAoB,EAAA,EAAI,EAAA;UACnDkD,OAAS,EAAA;AACPhB,YAAAA,GAAAA,EAAKU,QAASV,CAAAA,GAAAA;YACd4B,KAAO,EAAA,MAAMlB,SAASQ,IAAI,EAAA;AAC1BR,YAAAA;AACF,WAAA;UACAS,WAAa,EAAA;AAAC,YAAA,GAAA;AAAK,YAAA;YAAKL,QAASJ,CAAAA,QAAAA,CAASU,UAAU,GAAA;SACtD,CAAA;AACF;AAEA,MAAMnD,MAAAA,IAAAA,GAAO,MAAMyC,QAAAA,CAASwB,IAAI,EAAA;AAChC,MAAM9C,MAAAA,OAAAA,CAAQkB,KAAK,cAAgB,EAAA;AAAEI,QAAAA,QAAAA;AAAUzC,QAAAA,IAAAA;AAAMqB,QAAAA;OAAM,CAAA;AAC3D,MAAOrB,OAAAA,IAAAA;AACT,KAAA,CAAA,OAAS2D,KAAO,EAAA;AACd,MAAMxC,MAAAA,OAAAA,CAAQkB,KAAK,YAAc,EAAA;AAAEsB,QAAAA,KAAAA;AAAOtC,QAAAA;OAAa,CAAA;AACvD,MAAMsC,MAAAA,KAAAA;KACR,SAAA;AACE,MAAMxC,MAAAA,OAAAA,CAAQkB,KAAK,WAAa,EAAA;AAAEhB,QAAAA;OAAa,CAAA;AACjD;AACF;AAEA,EAAA,MAAgBe,WAAW8B,KAAsD,EAAA;AAC/E,IAAA,MAAMC,QAAQ,EAAC;AACf,IAAA,KAAA,MAAWC,QAAY,IAAA;MAAC,MAAM,IAAA,CAAK/C,MAAMc,OAAO,IAAA;AAAM+B,MAAAA;AAAOG,KAAAA,CAAAA,MAAAA,CAAOC,QAAAA,CAAW,EAAA;AAC7E,MAAA,IAAI7D,OAAQ2D,CAAAA,QAAAA,CAAaA,IAAAA,QAAAA,YAAoBG,OAAS,EAAA;AACpDlE,QAAAA,MAAAA,CAAOmE,OAAOL,KAAO9D,EAAAA,MAAAA,CAAOoE,YAAYL,QAAS9D,CAAAA,OAAAA,EAAO,CAAA,CAAA;OACnD,MAAA;AACLD,QAAOmE,MAAAA,CAAAA,MAAAA,CAAOL,OAAOC,QAAAA,CAAAA;AACvB;AACF;AACA,IAAOD,OAAAA,KAAAA;AACT;AAEUnC,EAAAA,MAAAA,CAAOJ,IAAoB,EAAA;AACnC,IAAA,MAAMG,GAAM,GAAA,IAAI2C,GAAI,CAAA,IAAA,CAAKrD,MAAMsD,OAAO,CAAA;AACtC,IAAA,MAAMC,SAAY,GAAA,IAAA,CAAKvD,KAAMwD,CAAAA,KAAAA,CAAMjD,IAAAA,CAASA,IAAAA,IAAAA;AAC5C,IAAA,IAAIG,GAAI+C,CAAAA,QAAAA,CAASC,QAAS,CAAA,GAAA,CAAM,EAAA;AAC9BhD,MAAAA,GAAAA,CAAI+C,QAAYF,IAAAA,SAAAA,CAAUI,OAAQ,CAAA,KAAA,EAAO,EAAA,CAAA;KACpC,MAAA;AACLjD,MAAAA,GAAAA,CAAI+C,QAAYF,IAAAA,SAAAA;AAClB;AACA,IAAO7C,OAAAA,GAAAA;AACT;EAEAkD,cAAiB,GAAA;AACf,IAAO,OAAA;MACL5D,KAAO6D,EAAAA,WAAAA,CAAY,KAAK7D,KAAK,CAAA;AAC7BF,MAAAA,OAAAA,EAAS,IAAKA,CAAAA;AAChB,KAAA;AACF;AAEAgE,EAAAA,YAAAA,CAAaC,QAAwD,EAAA;AACnE/E,IAAOmE,MAAAA,CAAAA,MAAAA,CAAO,MAAMY,QAAAA,CAAAA;AACtB;AACF","file":"fetcher.js","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FrameworkError } from \"@/errors.js\";\nimport { Serializable } from \"@/internals/serializable.js\";\nimport {\n  EventSourceMessage,\n  EventStreamContentType,\n  fetchEventSource,\n} from \"@ai-zen/node-fetch-event-source\";\nimport { FetchEventSourceInit } from \"@ai-zen/node-fetch-event-source/lib/cjs/fetch.js\";\nimport { emitterToGenerator } from \"@/internals/helpers/promise.js\";\nimport { doNothing, isArray, isPlainObject, isTruthy } from \"remeda\";\nimport { Callback, Emitter } from \"@/emitter/emitter.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\n\nexport class RestfulClientError extends FrameworkError {}\n\ntype URLParamType = string | number | boolean | null | undefined;\nexport function createURLParams(\n  data: Record<string, URLParamType | URLParamType[] | Record<string, any>>,\n) {\n  const urlTokenParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(data)) {\n    if (value === undefined) {\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        if (v !== undefined) {\n          urlTokenParams.append(key, String(v));\n        }\n      });\n    } else if (isPlainObject(value)) {\n      urlTokenParams.set(key, createURLParams(value).toString());\n    } else {\n      urlTokenParams.set(key, String(value));\n    }\n  }\n  return urlTokenParams;\n}\n\ninterface FetchInput {\n  url: string;\n  options: RequestInit;\n}\n\nexport interface StreamInput {\n  url: string;\n  options: FetchEventSourceInit;\n}\n\nexport interface RestfulClientEvents {\n  fetchStart: Callback<{ input: FetchInput }>;\n  fetchError: Callback<{ error: Error; input: FetchInput }>;\n  fetchSuccess: Callback<{ response: Response; data: any; input: FetchInput }>;\n  fetchDone: Callback<{ input: FetchInput }>;\n\n  streamStart: Callback<{ input: StreamInput }>;\n  streamOpen: Callback<{ input: StreamInput }>;\n  streamSuccess: Callback<{ input: StreamInput }>;\n  streamMessage: Callback<{ data: EventSourceMessage; input: StreamInput }>;\n  streamError: Callback<{ error: Error; input: StreamInput }>;\n  streamDone: Callback<{ input: StreamInput }>;\n}\n\nexport class RestfulClient<K extends Record<string, string>> extends Serializable {\n  public readonly emitter = Emitter.root.child<RestfulClientEvents>({\n    namespace: [\"internals\", \"restfulClient\"],\n    creator: this,\n  });\n\n  constructor(\n    protected input: {\n      baseUrl: string;\n      headers?: () => Promise<HeadersInit>;\n      paths: K;\n    },\n  ) {\n    super();\n  }\n\n  async *stream(\n    path: keyof K,\n    init: FetchEventSourceInit,\n  ): AsyncGenerator<EventSourceMessage, void, void> {\n    const emitter = this.emitter.child({\n      groupId: \"stream\",\n    });\n\n    const input: StreamInput = {\n      url: this.getUrl(path).toString(),\n      options: {\n        method: \"POST\",\n        ...init,\n        headers: await this.getHeaders(init?.headers),\n      },\n    };\n    await emitter.emit(\"streamStart\", { input });\n\n    return yield* emitterToGenerator(async ({ emit }) =>\n      fetchEventSource(input.url, {\n        ...input.options,\n        async onopen(response) {\n          const contentType = response.headers.get(\"content-type\") || \"\";\n          if (response.ok && contentType.includes(EventStreamContentType)) {\n            await emitter.emit(\"streamOpen\", { input });\n            return;\n          }\n          throw new RestfulClientError(\"Failed to stream!\", [], {\n            context: {\n              url: response.url,\n              err: await response.text(),\n              response,\n            },\n            isRetryable: response.status >= 400 && response.status < 500 && response.status !== 429,\n          });\n        },\n        async onmessage(msg) {\n          if (msg?.event === \"error\") {\n            throw new RestfulClientError(`Error during streaming has occurred.`, [], {\n              context: msg,\n            });\n          }\n          await emitter.emit(\"streamMessage\", { input, data: msg });\n          emit(msg);\n        },\n        onclose() {},\n        onerror(err) {\n          throw new RestfulClientError(`Error during streaming has occurred.`, [err]);\n        },\n      })\n        .then(() => emitter.emit(\"streamSuccess\", { input }))\n        .catch(async (error) => {\n          await emitter.emit(\"streamError\", { input, error }).catch(doNothing());\n          throw error;\n        })\n        .finally(() => emitter.emit(\"streamDone\", { input })),\n    );\n  }\n\n  async fetch(path: keyof K, init?: RequestInit & { searchParams?: URLSearchParams }) {\n    const emitter = this.emitter.child({\n      groupId: \"fetch\",\n    });\n\n    const target = this.getUrl(path);\n    if (init?.searchParams) {\n      for (const [key, value] of init.searchParams) {\n        target.searchParams.set(key, value);\n      }\n    }\n\n    const input: FetchInput = {\n      url: target.toString(),\n      options: {\n        ...init,\n        headers: await this.getHeaders(init?.headers),\n      },\n    };\n\n    await emitter.emit(\"fetchStart\", { input });\n    try {\n      const response = await fetch(input.url, input.options);\n\n      if (!response.ok) {\n        throw new RestfulClientError(\"Fetch has failed\", [], {\n          context: {\n            url: response.url,\n            error: await response.text(),\n            response,\n          },\n          isRetryable: [408, 503].includes(response.status ?? 500),\n        });\n      }\n\n      const data = await response.json();\n      await emitter.emit(\"fetchSuccess\", { response, data, input });\n      return data;\n    } catch (error) {\n      await emitter.emit(\"fetchError\", { error, input: input });\n      throw error;\n    } finally {\n      await emitter.emit(\"fetchDone\", { input: input });\n    }\n  }\n\n  protected async getHeaders(extra?: HeadersInit): Promise<Record<string, string>> {\n    const final = {};\n    for (const override of [await this.input.headers?.(), extra].filter(isTruthy)) {\n      if (isArray(override) || override instanceof Headers) {\n        Object.assign(final, Object.fromEntries(override.entries()));\n      } else {\n        Object.assign(final, override);\n      }\n    }\n    return final;\n  }\n\n  protected getUrl(path: keyof K): URL {\n    const url = new URL(this.input.baseUrl);\n    const extraPath = this.input.paths[path] ?? path;\n    if (url.pathname.endsWith(\"/\")) {\n      url.pathname += extraPath.replace(/^\\//, \"\");\n    } else {\n      url.pathname += extraPath;\n    }\n    return url;\n  }\n\n  createSnapshot() {\n    return {\n      input: shallowCopy(this.input),\n      emitter: this.emitter,\n    };\n  }\n\n  loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>): void {\n    Object.assign(this, snapshot);\n  }\n}\n"]}