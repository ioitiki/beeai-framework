{"version":3,"sources":["serializable.ts"],"names":["Serializable","constructor","Object","getPrototypeOf","register","Cache","init","aliases","Serializer","registerSerializable","undefined","clone","snapshot","createSnapshot","target","create","prototype","loadSnapshot","serialize","extractClassName","deserialize","value","options","__root","deserializeWithMeta","extraClasses","console","warn","current","SerializerError","fromSnapshot","state","fromSerialized","serialized"],"mappings":";;;;;;;AAkCO,MAAeA,YAAAA,CAAAA;EAlCtB;;;EAsCEC,WAAc,GAAA;AACZC,IAAAA,MAAAA,CAAOC,cAAe,CAAA,IAAI,CAAEF,CAAAA,WAAAA,CAAYG,QAAQ,EAAA;AAChDC,IAAAA,KAAAA,CAAMC,KAAK,IAAI,CAAA;AACjB;AAEA,EAAA,OAAcF,SAAwCG,OAAoB,EAAA;AACxEC,IAAWC,UAAAA,CAAAA,oBAAAA,CAAqB,IAAMC,EAAAA,MAAAA,EAAWH,OAAAA,CAAAA;AACnD;AAEA,EAAA,MAAMI,KAAmD,GAAA;AACvD,IAAMC,MAAAA,QAAAA,GAAW,MAAM,IAAA,CAAKC,cAAc,EAAA;AAE1C,IAAA,MAAMC,MAASZ,GAAAA,MAAAA,CAAOa,MAAO,CAAA,IAAA,CAAKd,YAAYe,SAAS,CAAA;AACvD,IAAMF,MAAAA,MAAAA,CAAOG,aAAaL,QAAAA,CAAAA;AAC1B,IAAOE,OAAAA,MAAAA;AACT;AAEA,EAAA,MAAMI,SAA6B,GAAA;AACjC,IAAMN,MAAAA,QAAAA,GAAW,MAAM,IAAA,CAAKC,cAAc,EAAA;AAC1C,IAAO,OAAA,MAAML,WAAWU,SAAoC,CAAA;AAC1DJ,MAAAA,MAAAA,EAAQK,iBAAiB,IAAI,CAAA;AAC7BP,MAAAA;KACF,CAAA;AACF;EAEA,MAAgBQ,WAAAA,CAAYC,OAAeC,OAA0C,EAAA;AACnF,IAAM,MAAA,EAAEC,QAAW,GAAA,MAAMf,WAAWgB,mBAClCH,CAAAA,KAAAA,EACAC,SAASG,YAAAA,CAAAA;AAEX,IAAI,IAAA,CAACF,OAAOT,MAAQ,EAAA;AAElBY,MAAAA,OAAAA,CAAQC,KACN,CAAwI,sIAAA,CAAA,CAAA;AAE1I,MAAOJ,OAAAA,MAAAA;AACT;AAEA,IAAMK,MAAAA,OAAAA,GAAUT,iBAAiB,IAAI,CAAA;AACrC,IAAIS,IAAAA,OAAAA,KAAYL,OAAOT,MAAQ,EAAA;AAC7B,MAAA,MAAM,IAAIe,eACR,CAAA,CAAA,qCAAA,EAAwCN,OAAOT,MAAM,CAAA,oCAAA,EAAuCc,OAAAA,CAAW,EAAA,CAAA,CAAA;AAE3G;AACA,IAAA,OAAOL,MAAOX,CAAAA,QAAAA;AAChB;AAEA,EAAA,aAAakB,aAEXC,KACY,EAAA;AACZ,IAAA,MAAMjB,MAASZ,GAAAA,MAAAA,CAAOa,MAAO,CAAA,IAAA,CAAKC,SAAS,CAAA;AAC3C,IAAMF,MAAAA,MAAAA,CAAOG,aAAac,KAAAA,CAAAA;AAC1B1B,IAAAA,KAAAA,CAAMC,KAAKQ,MAAAA,CAAAA;AACX,IAAOA,OAAAA,MAAAA;AACT;AAEA,EAAA,aAAakB,cAEXC,CAAAA,UAAAA,EACAX,OAA8B,GAAA,EAClB,EAAA;AACZ,IAAA,MAAMR,MAASZ,GAAAA,MAAAA,CAAOa,MAAO,CAAA,IAAA,CAAKC,SAAS,CAAA;AAC3C,IAAA,MAAMe,KAAQ,GAAA,MAAMjB,MAAOM,CAAAA,WAAAA,CAAYa,YAAYX,OAAAA,CAAAA;AACnD,IAAMR,MAAAA,MAAAA,CAAOG,aAAac,KAAAA,CAAAA;AAC1B1B,IAAAA,KAAAA,CAAMC,KAAKQ,MAAAA,CAAAA;AACX,IAAOA,OAAAA,MAAAA;AACT;AACF","file":"serializable.js","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Serializer } from \"@/serializer/serializer.js\";\nimport { ClassConstructor } from \"@/internals/types.js\";\nimport { extractClassName } from \"@/serializer/utils.js\";\nimport { SerializerError } from \"@/serializer/error.js\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\n\nexport type SerializableClass<T> = ClassConstructor<Serializable<T>> &\n  Pick<typeof Serializable<T>, \"fromSnapshot\" | \"fromSerialized\">;\n\ninterface SerializableStructure<T> {\n  target: string;\n  snapshot: T;\n}\n\nexport interface DeserializeOptions {\n  extraClasses?: SerializableClass<unknown>[];\n}\n\nexport abstract class Serializable<T = unknown> {\n  abstract createSnapshot(): T | Promise<T>;\n  abstract loadSnapshot(snapshot: T): void | Promise<void>;\n\n  constructor() {\n    Object.getPrototypeOf(this).constructor.register();\n    Cache.init(this);\n  }\n\n  public static register<T>(this: SerializableClass<T>, aliases?: string[]) {\n    Serializer.registerSerializable(this, undefined, aliases);\n  }\n\n  async clone<T extends Serializable>(this: T): Promise<T> {\n    const snapshot = await this.createSnapshot();\n\n    const target = Object.create(this.constructor.prototype) as T;\n    await target.loadSnapshot(snapshot);\n    return target;\n  }\n\n  async serialize(): Promise<string> {\n    const snapshot = await this.createSnapshot();\n    return await Serializer.serialize<SerializableStructure<T>>({\n      target: extractClassName(this),\n      snapshot,\n    });\n  }\n\n  protected async deserialize(value: string, options?: DeserializeOptions): Promise<T> {\n    const { __root } = await Serializer.deserializeWithMeta<SerializableStructure<T>>(\n      value,\n      options?.extraClasses,\n    );\n    if (!__root.target) {\n      // eslint-disable-next-line\n      console.warn(\n        `Serializable class must be serialized via \"serialize\" method and not via Serializer class. This may lead to incorrect deserialization.`,\n      );\n      return __root as T;\n    }\n\n    const current = extractClassName(this);\n    if (current !== __root.target) {\n      throw new SerializerError(\n        `Snapshot has been created for class '${__root.target}' but you want to use it for class '${current}'.`,\n      );\n    }\n    return __root.snapshot;\n  }\n\n  static async fromSnapshot<P, T extends Serializable<P>>(\n    this: new (...args: any[]) => T,\n    state: P,\n  ): Promise<T> {\n    const target = Object.create(this.prototype);\n    await target.loadSnapshot(state);\n    Cache.init(target);\n    return target;\n  }\n\n  static async fromSerialized<T extends Serializable>(\n    this: abstract new (...args: any[]) => T,\n    serialized: string,\n    options: DeserializeOptions = {},\n  ): Promise<T> {\n    const target = Object.create(this.prototype) as T;\n    const state = await target.deserialize(serialized, options);\n    await target.loadSnapshot(state);\n    Cache.init(target);\n    return target;\n  }\n}\n"]}