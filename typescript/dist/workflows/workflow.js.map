{"version":3,"sources":["workflow.ts"],"names":["WorkflowError","FrameworkError","constructor","message","extra","errors","context","run","isRetryable","isFatal","Workflow","Serializable","START","SELF","PREV","NEXT","END","emitter","steps","startStep","input","Map","undefined","Emitter","root","child","namespace","toCamelCase","name","filter","Boolean","creator","getSteps","Array","from","keys","schemas","pick","addStep","step","_addStep","addStrictStep","schema","schemaOrStep","stepOrEmpty","trim","ValueError","has","stepOrFlow","set","handler","asStep","setStart","state","options","RunContext","enter","signal","params","runContext","parse","result","handlers","abort","reason","next","findStep","start","current","get","emit","parseAsync","catch","err","shallowCopy","then","deepCopy","nextStepRaw","at","prev","stepResult","push","error","outputSchema","delStep","delete","overrides","ctx","mappedInput","mappedOutput","output","Object","assign","index","indexOf","createSnapshot","omit","loadSnapshot","snapshot","z","any"],"mappings":";;;;;;;;;;AA0FO,MAAMA,sBAIHC,cAAAA,CAAAA;EA9FV;;;AA+FEC,EAAAA,WAAAA,CAAYC,SAAiBC,KAA2D,EAAA;AACtF,IAAMD,KAAAA,CAAAA,OAAAA,EAASC,OAAOC,MAAQ,EAAA;MAC5BC,OAASF,EAAAA,KAAAA,EAAOG,OAAO,EAAC;MACxBC,WAAa,EAAA,KAAA;MACbC,OAAS,EAAA;KACX,CAAA;AACF;AACF;AAEO,MAAMC,iBAIHC,YAAAA,CAAAA;EA5GV;;;;AA6GE,EAAA,OAAuBC,KAAQ,GAAA,WAAA;AAC/B,EAAA,OAAuBC,IAAO,GAAA,UAAA;AAC9B,EAAA,OAAuBC,IAAO,GAAA,UAAA;AAC9B,EAAA,OAAuBC,IAAO,GAAA,UAAA;AAC9B,EAAA,OAAuBC,GAAM,GAAA,SAAA;AAEbC,EAAAA,OAAAA;AAEGC,EAAAA,KAAAA;AACTC,EAAAA,SAAAA;AAEVjB,EAAAA,WAAAA,CAA+BkB,KAAmC,EAAA;AAChE,IAAK,KAAA,EAAA,EAAA,IADwBA,CAAAA,KAAAA,GAAAA,KAAAA,EAAAA,IAAAA,CAHZF,wBAAYG,IAAAA,GAAAA,EAAAA,EAAAA,IAAAA,CACrBF,SAA+BG,GAAAA,MAAAA;AAIvC,IAAKL,IAAAA,CAAAA,OAAAA,GAAUM,OAAQC,CAAAA,IAAAA,CAAKC,KAAM,CAAA;MAChCC,SAAW,EAAA;AAAC,QAAA,UAAA;QAAYC,WAAYP,CAAAA,KAAAA,EAAOQ,QAAQ,EAAA;AAAKC,OAAAA,CAAAA,MAAAA,CAAOC,OAAAA,CAAAA;MAC/DC,OAAS,EAAA;KACX,CAAA;AACF;EAEAC,QAAW,GAAA;AACT,IAAA,OAAOC,KAAMC,CAAAA,IAAAA,CAAK,IAAKhB,CAAAA,KAAAA,CAAMiB,MAAI,CAAA;AACnC;AAEA,EAAA,IAAIP,IAAO,GAAA;AACT,IAAO,OAAA,IAAA,CAAKR,MAAMQ,IAAQ,IAAA,EAAA;AAC5B;AAEA,EAAA,IAAIQ,OAAU,GAAA;AACZ,IAAOC,OAAAA,IAAAA,CAAK,KAAKjB,KAAO,EAAA;AAAC,MAAA,QAAA;AAAU,MAAA;AAAe,KAAA,CAAA;AACpD;AAUAkB,EAAAA,OAAAA,CACEV,MACAW,IACsC,EAAA;AACtC,IAAO,OAAA,IAAA,CAAKC,QAASZ,CAAAA,IAAAA,EAAMW,IAAAA,CAAAA;AAC7B;EAYAE,aACEb,CAAAA,IAAAA,EACAc,QACAH,IACsC,EAAA;AACtC,IAAA,OAAO,IAAKC,CAAAA,QAAAA,CAASZ,IAAMc,EAAAA,MAAAA,EAAQH,IAAAA,CAAAA;AACrC;EAEUC,QACRZ,CAAAA,IAAAA,EACAe,cACAC,WACsC,EAAA;AACtC,IAAI,IAAA,CAAChB,IAAKiB,CAAAA,IAAAA,EAAQ,EAAA;AAChB,MAAM,MAAA,IAAIC,WAAW,CAA4B,0BAAA,CAAA,CAAA;AACnD;AACA,IAAA,IAAI,IAAK5B,CAAAA,KAAAA,CAAM6B,GAAInB,CAAAA,IAAAA,CAAO,EAAA;AACxB,MAAA,MAAM,IAAIkB,UAAAA,CAAW,CAASlB,MAAAA,EAAAA,IAAAA,CAAuB,iBAAA,CAAA,CAAA;AACvD;AACA,IAAIA,IAAAA,IAAAA,KAASlB,SAASM,GAAK,EAAA;AACzB,MAAA,MAAM,IAAI8B,UAAAA,CAAW,CAAalB,UAAAA,EAAAA,IAAAA,CAAuB,iBAAA,CAAA,CAAA;AAC3D;AAEA,IAAA,MAAMc,MAAUC,GAAAA,YAAAA,IAAgBC,WAAcD,GAAAA,YAAAA,GAAe,KAAKvB,KAAMsB,CAAAA,MAAAA;AACxE,IAAA,MAAMM,aAAaJ,WAAeD,IAAAA,YAAAA;AAElC,IAAKzB,IAAAA,CAAAA,KAAAA,CAAM+B,IAAIrB,IAAM,EAAA;AACnBc,MAAAA,MAAAA;AACAQ,MAAAA,OAAAA,EAASF,sBAAsBtC,QAAWsC,GAAAA,UAAAA,CAAWG,MAAO,CAAA,EAAC,CAAKH,GAAAA;KACpE,CAAA;AAEA,IAAO,OAAA,IAAA;AACT;AAEAI,EAAAA,QAAAA,CAASxB,IAAa,EAAA;AACpB,IAAA,IAAA,CAAKT,SAAYS,GAAAA,IAAAA;AACjB,IAAO,OAAA,IAAA;AACT;EAEArB,GAAI8C,CAAAA,KAAAA,EAAwBC,OAAqC,GAAA,EAAI,EAAA;AACnE,IAAOC,OAAAA,UAAAA,CAAWC,MAChB,IACA,EAAA;AAAEC,MAAAA,MAAAA,EAAQH,OAASG,EAAAA,MAAAA;MAAQC,MAAQ,EAAA;AAACL,QAAAA,KAAAA;AAAOC,QAAAA;;AAAkB,KAAA,EAC7D,OAAOK,UAAAA,KAAAA;AACL,MAAA,MAAMpD,GAA2C,GAAA;AAC/CW,QAAAA,KAAAA,EAAO,EAAA;AACPmC,QAAAA,KAAAA,EAAO,IAAKjC,CAAAA,KAAAA,CAAMsB,MAAOkB,CAAAA,KAAAA,CAAMP,KAAAA,CAAAA;QAC/BQ,MAAQvC,EAAAA;AACV,OAAA;AACA,MAAA,MAAMwC,QAA8C,GAAA;AAClD5C,QAAAA,KAAAA,EAAOX,GAAIW,CAAAA,KAAAA;AACXuC,QAAAA,MAAAA,EAAQE,UAAWF,CAAAA,MAAAA;AACnBM,QAAAA,KAAAA,kBAAQC,MAAAA,CAAAA,CAAAA,MAAAA,KAAWL,UAAWI,CAAAA,KAAAA,CAAMC,MAAAA,CAA7B,EAAA,OAAA;AACT,OAAA;AAEA,MAAA,IAAIC,IACF,GAAA,IAAA,CAAKC,QAASZ,CAAAA,OAAAA,EAASa,SAAS,IAAKhD,CAAAA,SAAAA,IAAa,IAAKa,CAAAA,QAAAA,EAAW,CAAA,CAAA,CAAE,CAAA,CAAEoC,WACtE1D,QAASM,CAAAA,GAAAA;AAEX,MAAOiD,OAAAA,IAAAA,IAAQA,IAASvD,KAAAA,QAAAA,CAASM,GAAK,EAAA;AACpC,QAAA,MAAMY,IAAOqC,GAAAA,IAAAA;AACb,QAAA,MAAM1B,IAAO,GAAA,IAAA,CAAKrB,KAAMmD,CAAAA,GAAAA,CAAIJ,IAAAA,CAAAA;AAC5B,QAAA,IAAI,CAAC1B,IAAM,EAAA;AACT,UAAA,MAAM,IAAIvC,aAAAA,CAAc,CAASiE,MAAAA,EAAAA,IAAAA,CAAwB,gBAAA,CAAA,EAAA;AAAE1D,YAAAA;WAAI,CAAA;AACjE;AACA,QAAMoD,MAAAA,UAAAA,CAAW1C,OAAQqD,CAAAA,IAAAA,CAAK,OAAS,EAAA;AAAE/D,UAAAA,GAAAA;UAAKgC,IAAM0B,EAAAA;SAAK,CAAA;AACzD,QAAI,IAAA;AACF,UAAMZ,MAAAA,MAAAA,GAAQ,MAAMd,IAAAA,CAAKG,MACtB6B,CAAAA,UAAAA,CAAWhE,IAAI8C,KAAK,CAAA,CACpBmB,KAAM,CAAA,OAAOC,GAAAA,KAAAA;AACZ,YAAA,MAAM,IAAIzE,aAAAA,CACR,CAASiE,MAAAA,EAAAA,IAAAA,CACT,oFAAA,CAAA,EAAA;AAAE1D,cAAAA,GAAAA,EAAKmE,YAAYnE,GAAAA,CAAAA;cAAMF,MAAQ,EAAA;AAACoE,gBAAAA;;aAAK,CAAA;WAE3C,CAAA,CACCE,KAAKC,QAAAA,CAAAA;AAER,UAAA,MAAMC,WAAc,GAAA,MAAMtC,IAAKW,CAAAA,OAAAA,CAAQG,QAAOS,QAAAA,CAAAA;AAC9C,UAAIe,IAAAA,WAAAA,KAAgBnE,SAASE,KAAO,EAAA;AAClCqD,YAAAA,IAAAA,GAAO1D,GAAIW,CAAAA,KAAAA,CAAM4D,EAAG,CAAA,CAAA,CAAIlD,EAAAA,IAAAA;WACfiD,MAAAA,IAAAA,WAAAA,KAAgBnE,SAASI,IAAM,EAAA;AACxCmD,YAAO,IAAA,GAAA,IAAA,CAAKC,QAASD,CAAAA,IAAAA,CAAMc,CAAAA,IAAAA;WAClBF,MAAAA,IAAAA,WAAAA,KAAgBnE,SAASG,IAAM,EAAA;AACxCoD,YAAO,IAAA,GAAA,IAAA,CAAKC,QAASD,CAAAA,IAAAA,CAAMG,CAAAA,OAAAA;AAC7B,WAAA,MAAA,IAAW,CAACS,WAAAA,IAAeA,WAAgBnE,KAAAA,QAAAA,CAASK,IAAM,EAAA;AACxDkD,YAAAA,IAAAA,GAAO,IAAKC,CAAAA,QAAAA,CAASD,IAAAA,CAAAA,CAAMA,QAAQvD,QAASM,CAAAA,GAAAA;WACvC,MAAA;AACLiD,YAAOY,IAAAA,GAAAA,WAAAA;AACT;AAEA,UAAA,MAAMG,UAA6C,GAAA;AACjDpD,YAAAA,IAAAA;YACAyB,KAAAA,EAAAA,MAAAA;AACAY,YAAAA;AACF,WAAA;AACA1D,UAAIW,GAAAA,CAAAA,KAAAA,CAAM+D,KAAKD,UAAAA,CAAAA;AACfzE,UAAAA,GAAAA,CAAI8C,QAAQ2B,UAAW3B,CAAAA,KAAAA;AAEvB,UAAMM,MAAAA,UAAAA,CAAW1C,OAAQqD,CAAAA,IAAAA,CAAK,SAAW,EAAA;AACvC/D,YAAAA,GAAAA,EAAKmE,YAAYnE,GAAAA,CAAAA;AACjB8C,YAAAA,KAAAA,EAAO2B,UAAW3B,CAAAA,KAAAA;AAClBd,YAAAA,IAAAA,EAAMyC,UAAWpD,CAAAA,IAAAA;AACjBqC,YAAAA,IAAAA,EAAMe,UAAWf,CAAAA;WACnB,CAAA;AACF,SAAA,CAAA,OAASiB,KAAO,EAAA;AACd,UAAMvB,MAAAA,UAAAA,CAAW1C,OAAQqD,CAAAA,IAAAA,CAAK,OAAS,EAAA;AACrC/D,YAAAA,GAAAA,EAAKmE,YAAYnE,GAAAA,CAAAA;YACjBgC,IAAM0B,EAAAA,IAAAA;AACNiB,YAAAA;WACF,CAAA;AACA,UAAMA,MAAAA,KAAAA;AACR;AACF;AAEA3E,MAAAA,GAAAA,CAAIsD,MAAS,GAAA,MAAA,CAAO,IAAKzC,CAAAA,KAAAA,CAAM+D,gBAAgB,IAAK/D,CAAAA,KAAAA,CAAMsB,MACvD6B,EAAAA,UAAAA,CAAWhE,GAAI8C,CAAAA,KAAK,CACpBmB,CAAAA,KAAAA,CAAM,CAACC,GAAAA,KAAAA;AACN,QAAM,MAAA,IAAIzE,cACR,CACA,kFAAA,CAAA,EAAA;AAAEO,UAAAA,GAAAA,EAAKmE,YAAYnE,GAAAA,CAAAA;UAAMF,MAAQ,EAAA;AAACoE,YAAAA;;SAAK,CAAA;OAE3C,CAAA;AACF,MAAOlE,OAAAA,GAAAA;KACT,CAAA;AAEJ;AAEA6E,EAAAA,OAAAA,CAAyBxD,IAAuD,EAAA;AAC9E,IAAI,IAAA,IAAA,CAAKT,cAAcS,IAAM,EAAA;AAC3B,MAAA,IAAA,CAAKT,SAAYG,GAAAA,MAAAA;AACnB;AACA,IAAKJ,IAAAA,CAAAA,KAAAA,CAAMmE,OAAOzD,IAAAA,CAAAA;AAClB,IAAO,OAAA,IAAA;AACT;AAEAuB,EAAAA,MAAAA,CAIEmC,SAK+C,EAAA;AAC/C,IAAO,OAAA,OAAOjC,OAAOkC,GAAAA,KAAAA;AACnB,MAAA,MAAMC,cAAcF,SAAWlE,EAAAA,KAAAA,GAAQkE,SAAUlE,CAAAA,KAAAA,CAAMiC,KAAAA,CAASA,GAAAA,KAAAA;AAChE,MAAA,MAAMQ,MAAS,GAAA,MAAM,IAAKtD,CAAAA,GAAAA,CAAIiF,WAAa,EAAA;AAAErB,QAAAA,KAAAA,EAAOmB,SAAWnB,EAAAA,KAAAA;AAAOV,QAAAA,MAAAA,EAAQ8B,GAAI9B,CAAAA;OAAO,CAAA;AACzF,MAAMgC,MAAAA,YAAAA,GAAeH,WAAWI,MAASJ,GAAAA,SAAAA,CAAUI,OAAO7B,MAAOR,CAAAA,KAAK,IAAIQ,MAAOR,CAAAA,KAAAA;AACjFsC,MAAOC,MAAAA,CAAAA,MAAAA,CAAOvC,OAAOoC,YAAAA,CAAAA;AACrB,MAAA,OAAOH,SAAUrB,CAAAA,IAAAA;AACnB,KAAA;AACF;AAEUC,EAAAA,QAAAA,CAASE,OAAgB,EAAA;AACjC,IAAMlD,MAAAA,KAAAA,GAAQ,KAAKc,QAAQ,EAAA;AAC3B,IAAM6D,MAAAA,KAAAA,GAAQ3E,KAAM4E,CAAAA,OAAAA,CAAQ1B,OAAAA,CAAAA;AAC5B,IAAO,OAAA;MACLW,IAAM7D,EAAAA,KAAAA,CAAM2E,QAAQ,CAAA,CAAA;AACpBzB,MAAAA,OAAAA,EAASlD,MAAM2E,KAAAA,CAAAA;MACf5B,IAAM/C,EAAAA,KAAAA,CAAM2E,QAAQ,CAAA;AACtB,KAAA;AACF;EAEAE,cAAiB,GAAA;AACf,IAAO,OAAA;MACL3E,KAAO4E,EAAAA,IAAAA,CAAK,KAAK5E,KAAO,EAAA;AAAC,QAAA,QAAA;AAAU,QAAA;AAAe,OAAA,CAAA;AAClDH,MAAAA,OAAAA,EAAS,IAAKA,CAAAA,OAAAA;AACdE,MAAAA,SAAAA,EAAW,IAAKA,CAAAA,SAAAA;AAChBD,MAAAA,KAAAA,EAAO,IAAKA,CAAAA;AACd,KAAA;AACF;AAEA+E,EAAAA,YAAAA,CAAaC,QAAkD,EAAA;AAC7DP,IAAOC,MAAAA,CAAAA,MAAAA,CAAO,MAAMM,QAAAA,CAAAA;AACpB,IAAK9E,IAAAA,CAAAA,KAAAA,CAAMsB,MAAWyD,KAAAA,CAAAA,CAAEC,GAAG,EAAA;AAC3B,IAAKhF,IAAAA,CAAAA,KAAAA,CAAM+D,YAAiBgB,KAAAA,CAAAA,CAAEC,GAAG,EAAA;AACnC;AACF","file":"workflow.js","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z, ZodSchema } from \"zod\";\nimport { Serializable } from \"@/internals/serializable.js\";\nimport { Callback, Emitter } from \"@/emitter/emitter.js\";\nimport { RunContext } from \"@/context.js\";\nimport { omit, pick, toCamelCase } from \"remeda\";\nimport { deepCopy, shallowCopy } from \"@/serializer/utils.js\";\nimport { FrameworkError, ValueError } from \"@/errors.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\ntype WorkflowStepHandlerReturn<K extends string> = K | ReservedStep | void;\n\nexport interface WorkflowRun<T extends ZodSchema, T2 extends ZodSchema, K extends string> {\n  result: z.output<T2>;\n  steps: WorkflowStepRes<T, K>[];\n  state: z.output<T>;\n}\n\nexport interface WorkflowRunOptions<K extends string> {\n  start?: K;\n  signal?: AbortSignal;\n}\n\nexport interface WorkflowStepDef<T extends ZodSchema, K extends string> {\n  schema: T;\n  handler: WorkflowStepHandler<T, K>;\n}\n\nexport interface WorkflowStepRes<T extends ZodSchema, K extends string> {\n  name: K;\n  next: K | ReservedStep;\n  state: z.output<T>;\n}\n\nexport interface WorkflowRunContext<T extends ZodSchema, K extends string> {\n  steps: WorkflowStepRes<T, K>[];\n  signal: AbortSignal;\n  abort: (reason?: Error) => void;\n}\n\nexport type WorkflowStepHandler<T extends ZodSchema, K extends string> = (\n  state: z.output<T>,\n  context: WorkflowRunContext<T, K>,\n) => Promise<WorkflowStepHandlerReturn<K>> | WorkflowStepHandlerReturn<K>;\n\nexport interface WorkflowEvents<T extends ZodSchema, T2 extends ZodSchema, K extends string> {\n  start: Callback<{ step: K; run: WorkflowRun<T, T2, K> }>;\n  error: Callback<{\n    step: K;\n    error: Error;\n    run: WorkflowRun<T, T2, K>;\n  }>;\n  success: Callback<{\n    step: K;\n    next: K | ReservedStep;\n    state: z.output<T>;\n    run: WorkflowRun<T, T2, K>;\n  }>;\n}\n\ninterface FlowInput<TS extends ZodSchema, TS2 extends ZodSchema = TS> {\n  name?: string;\n  schema: TS;\n  outputSchema?: TS2;\n}\n\ntype RunStep<K extends string> = K | typeof Workflow.END;\ntype ReservedStep =\n  | typeof Workflow.START\n  | typeof Workflow.NEXT\n  | typeof Workflow.PREV\n  | typeof Workflow.END\n  | typeof Workflow.SELF;\nexport type FlowStepName<K extends string> = K | ReservedStep;\n\nexport class WorkflowError<\n  T extends ZodSchema,\n  T2 extends ZodSchema,\n  K extends string,\n> extends FrameworkError {\n  constructor(message: string, extra?: { run?: WorkflowRun<T, T2, K>; errors?: Error[] }) {\n    super(message, extra?.errors, {\n      context: extra?.run ?? {},\n      isRetryable: false,\n      isFatal: true,\n    });\n  }\n}\n\nexport class Workflow<\n  TInput extends ZodSchema,\n  TOutput extends ZodSchema = TInput,\n  TKeys extends string = string,\n> extends Serializable {\n  public static readonly START = \"__start__\";\n  public static readonly SELF = \"__self__\";\n  public static readonly PREV = \"__prev__\";\n  public static readonly NEXT = \"__next__\";\n  public static readonly END = \"__end__\";\n\n  public readonly emitter: Emitter<WorkflowEvents<TInput, TOutput, TKeys>>;\n\n  protected readonly steps = new Map<string, WorkflowStepDef<TInput, TKeys>>();\n  protected startStep: TKeys | undefined = undefined;\n\n  constructor(protected readonly input: FlowInput<TInput, TOutput>) {\n    super();\n    this.emitter = Emitter.root.child({\n      namespace: [\"workflow\", toCamelCase(input?.name ?? \"\")].filter(Boolean),\n      creator: this,\n    });\n  }\n\n  getSteps() {\n    return Array.from(this.steps.keys()) as TKeys[];\n  }\n\n  get name() {\n    return this.input.name ?? \"\";\n  }\n\n  get schemas() {\n    return pick(this.input, [\"schema\", \"outputSchema\"]);\n  }\n\n  addStep<L extends string>(\n    name: L,\n    handler: WorkflowStepHandler<TInput | TOutput, TKeys>,\n  ): Workflow<TInput, TOutput, L | TKeys>;\n  addStep<L extends string, TFlow extends AnyWorkflowFlow>(\n    name: L,\n    flow: Workflow.pipeable<this, TFlow>,\n  ): Workflow<TInput, TOutput, L | TKeys>;\n  addStep<L extends string>(\n    name: L,\n    step: WorkflowStepHandler<TInput | TOutput, TKeys> | AnyWorkflowFlow,\n  ): Workflow<TInput, TOutput, L | TKeys> {\n    return this._addStep(name, step);\n  }\n\n  addStrictStep<L extends string, TI2 extends ZodSchema>(\n    name: L,\n    schema: TI2,\n    handler: WorkflowStepHandler<TI2, TKeys>,\n  ): Workflow<TInput, TOutput, L | TKeys>;\n  addStrictStep<L extends string, TI2 extends ZodSchema, TFlow extends AnyWorkflowFlow>(\n    name: L,\n    schema: TI2,\n    flow: Workflow.pipeable<Workflow<TI2, TOutput, TKeys>, TFlow>,\n  ): Workflow<TInput, TOutput, L | TKeys>;\n  addStrictStep<L extends string, TI2 extends ZodSchema>(\n    name: L,\n    schema: TI2,\n    step: WorkflowStepHandler<TI2, TKeys> | AnyWorkflowFlow,\n  ): Workflow<TInput, TOutput, L | TKeys> {\n    return this._addStep(name, schema, step);\n  }\n\n  protected _addStep<TI2 extends ZodSchema = TInput, L extends string = TKeys>(\n    name: L,\n    schemaOrStep: TI2 | WorkflowStepHandler<TInput, TKeys> | AnyWorkflowFlow,\n    stepOrEmpty?: WorkflowStepHandler<TI2, TKeys> | AnyWorkflowFlow,\n  ): Workflow<TInput, TOutput, L | TKeys> {\n    if (!name.trim()) {\n      throw new ValueError(`Step name cannot be empty!`);\n    }\n    if (this.steps.has(name)) {\n      throw new ValueError(`Step '${name}' already exists!`);\n    }\n    if (name === Workflow.END) {\n      throw new ValueError(`The name '${name}' cannot be used!`);\n    }\n\n    const schema = (schemaOrStep && stepOrEmpty ? schemaOrStep : this.input.schema) as TInput;\n    const stepOrFlow = stepOrEmpty || schemaOrStep;\n\n    this.steps.set(name, {\n      schema,\n      handler: stepOrFlow instanceof Workflow ? stepOrFlow.asStep({}) : stepOrFlow,\n    } as WorkflowStepDef<TInput, TKeys>);\n\n    return this as unknown as Workflow<TInput, TOutput, L | TKeys>;\n  }\n\n  setStart(name: TKeys) {\n    this.startStep = name;\n    return this;\n  }\n\n  run(state: z.input<TInput>, options: WorkflowRunOptions<TKeys> = {}) {\n    return RunContext.enter(\n      this,\n      { signal: options?.signal, params: [state, options] as const },\n      async (runContext): Promise<WorkflowRun<TInput, TOutput, TKeys>> => {\n        const run: WorkflowRun<TInput, TOutput, TKeys> = {\n          steps: [],\n          state: this.input.schema.parse(state),\n          result: undefined as z.output<TOutput>,\n        };\n        const handlers: WorkflowRunContext<TInput, TKeys> = {\n          steps: run.steps,\n          signal: runContext.signal,\n          abort: (reason) => runContext.abort(reason),\n        };\n\n        let next: RunStep<TKeys> =\n          this.findStep(options?.start || this.startStep || this.getSteps()[0]).current ??\n          Workflow.END;\n\n        while (next && next !== Workflow.END) {\n          const name = next;\n          const step = this.steps.get(next);\n          if (!step) {\n            throw new WorkflowError(`Step '${next}' was not found.`, { run });\n          }\n          await runContext.emitter.emit(\"start\", { run, step: next });\n          try {\n            const state = await step.schema\n              .parseAsync(run.state)\n              .catch(async (err: Error) => {\n                throw new WorkflowError(\n                  `Step '${next}' cannot be executed because the provided input doesn't adhere to the step's schema.`,\n                  { run: shallowCopy(run), errors: [err] },\n                );\n              })\n              .then(deepCopy);\n\n            const nextStepRaw = await step.handler(state, handlers);\n            if (nextStepRaw === Workflow.START) {\n              next = run.steps.at(0)?.name!;\n            } else if (nextStepRaw === Workflow.PREV) {\n              next = this.findStep(next).prev;\n            } else if (nextStepRaw === Workflow.SELF) {\n              next = this.findStep(next).current;\n            } else if (!nextStepRaw || nextStepRaw === Workflow.NEXT) {\n              next = this.findStep(next).next || Workflow.END;\n            } else {\n              next = nextStepRaw;\n            }\n\n            const stepResult: WorkflowStepRes<TInput, TKeys> = {\n              name,\n              state,\n              next,\n            };\n            run.steps.push(stepResult);\n            run.state = stepResult.state;\n\n            await runContext.emitter.emit(\"success\", {\n              run: shallowCopy(run),\n              state: stepResult.state,\n              step: stepResult.name,\n              next: stepResult.next,\n            });\n          } catch (error) {\n            await runContext.emitter.emit(\"error\", {\n              run: shallowCopy(run),\n              step: next as TKeys,\n              error,\n            });\n            throw error;\n          }\n        }\n\n        run.result = await (this.input.outputSchema ?? this.input.schema)\n          .parseAsync(run.state)\n          .catch((err) => {\n            throw new WorkflowError(\n              `Workflow has ended but it's state does not adhere to the workflow's output schema.`,\n              { run: shallowCopy(run), errors: [err] },\n            );\n          });\n        return run;\n      },\n    );\n  }\n\n  delStep<L extends TKeys>(name: L): Workflow<TInput, TOutput, Exclude<TKeys, L>> {\n    if (this.startStep === name) {\n      this.startStep = undefined;\n    }\n    this.steps.delete(name);\n    return this as unknown as Workflow<TInput, TOutput, Exclude<TKeys, L>>;\n  }\n\n  asStep<\n    TInput2 extends ZodSchema = TInput,\n    TOutput2 extends ZodSchema = TOutput,\n    TKeys2 extends string = TKeys,\n  >(overrides: {\n    input?: (input: z.output<TInput2>) => z.output<TInput> | z.input<TInput>;\n    output?: (output: z.output<TOutput>) => z.output<TOutput2> | z.input<TOutput2>;\n    start?: TKeys;\n    next?: FlowStepName<TKeys2>;\n  }): WorkflowStepHandler<TInput2, TKeys | TKeys2> {\n    return async (state, ctx) => {\n      const mappedInput = overrides?.input ? overrides.input(state) : state;\n      const result = await this.run(mappedInput, { start: overrides?.start, signal: ctx.signal });\n      const mappedOutput = overrides?.output ? overrides.output(result.state) : result.state;\n      Object.assign(state, mappedOutput);\n      return overrides.next;\n    };\n  }\n\n  protected findStep(current: TKeys) {\n    const steps = this.getSteps();\n    const index = steps.indexOf(current);\n    return {\n      prev: steps[index - 1],\n      current: steps[index],\n      next: steps[index + 1],\n    };\n  }\n\n  createSnapshot() {\n    return {\n      input: omit(this.input, [\"schema\", \"outputSchema\"]),\n      emitter: this.emitter,\n      startStep: this.startStep,\n      steps: this.steps,\n    };\n  }\n\n  loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>) {\n    Object.assign(this, snapshot);\n    this.input.schema ??= z.any() as unknown as TInput;\n    this.input.outputSchema ??= z.any() as unknown as TOutput;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Workflow {\n  export type pipeable<T extends AnyWorkflowFlow, T2 extends AnyWorkflowFlow> =\n    Workflow.state<T> extends Workflow.input<T2> ? T2 : never;\n  export type input<T> = T extends Workflow<infer A, any, any> ? z.input<A> : never;\n  export type state<T> = T extends Workflow<infer A, any, any> ? z.output<A> : never;\n  export type output<T> = T extends Workflow<any, infer A, any> ? z.output<A> : never;\n  export type run<T> = T extends Workflow<infer A, infer B, infer C> ? WorkflowRun<A, B, C> : never;\n}\n\nexport type AnyWorkflowFlow = Workflow<any, any, any>;\n"]}