{"version":3,"sources":["base.ts"],"names":["BaseRunner","Serializable","memory","iterations","failedAttemptsCounter","constructor","input","options","run","RetryCounter","execution","totalMaxRetries","AgentError","createIteration","meta","iteration","length","maxIterations","Infinity","isFatal","isRetryable","context","map","state","emitter","child","groupId","llm","signal","push","init","initMemory","templates","overrides","mapObj","defaultTemplates","key","defaultTemplate","override","PromptTemplate","createSnapshot","shallowCopy","loadSnapshot","snapshot","Object","assign","enumerable"],"mappings":"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","file":"base.cjs","sourcesContent":["/**\n * Copyright 2025 Â© BeeAI a Series of LF Projects, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Serializable } from \"@/internals/serializable.js\";\nimport type { ReActAgentTemplates } from \"@/agents/react/types.js\";\nimport {\n  ReActAgentRunIteration,\n  ReActAgentCallbacks,\n  ReActAgentIterationToolResult,\n  ReActAgentMeta,\n  ReActAgentRunInput,\n  ReActAgentRunOptions,\n} from \"@/agents/react/types.js\";\nimport type { ReActAgent, ReActAgentInput } from \"@/agents/react/agent.js\";\nimport { RetryCounter } from \"@/internals/helpers/counter.js\";\nimport { AgentError } from \"@/agents/base.js\";\nimport { shallowCopy } from \"@/serializer/utils.js\";\nimport { BaseMemory } from \"@/memory/base.js\";\nimport { GetRunContext } from \"@/context.js\";\nimport { Emitter } from \"@/emitter/emitter.js\";\nimport { Cache } from \"@/cache/decoratorCache.js\";\nimport { mapObj } from \"@/internals/helpers/object.js\";\nimport { PromptTemplate } from \"@/template.js\";\n\nexport interface ReActAgentRunnerLLMInput {\n  meta: ReActAgentMeta;\n  signal: AbortSignal;\n  emitter: Emitter<ReActAgentCallbacks>;\n}\n\nexport interface ReActAgentRunnerToolInput {\n  state: ReActAgentIterationToolResult;\n  meta: ReActAgentMeta;\n  signal: AbortSignal;\n  emitter: Emitter<ReActAgentCallbacks>;\n}\n\nexport abstract class BaseRunner extends Serializable {\n  public memory!: BaseMemory;\n  public readonly iterations: ReActAgentRunIteration[] = [];\n  protected readonly failedAttemptsCounter: RetryCounter;\n\n  constructor(\n    protected readonly input: ReActAgentInput,\n    protected readonly options: ReActAgentRunOptions,\n    protected readonly run: GetRunContext<ReActAgent>,\n  ) {\n    super();\n    this.failedAttemptsCounter = new RetryCounter(options?.execution?.totalMaxRetries, AgentError);\n  }\n\n  async createIteration() {\n    const meta: ReActAgentMeta = { iteration: this.iterations.length + 1 };\n    const maxIterations = this.options?.execution?.maxIterations ?? Infinity;\n\n    if (meta.iteration > maxIterations) {\n      throw new AgentError(\n        `Agent was not able to resolve the task in ${maxIterations} iterations.`,\n        [],\n        {\n          isFatal: true,\n          isRetryable: false,\n          context: { iterations: this.iterations.map((iteration) => iteration.state) },\n        },\n      );\n    }\n\n    const emitter = this.run.emitter.child({ groupId: `iteration-${meta.iteration}` });\n    const iteration = await this.llm({ emitter, signal: this.run.signal, meta });\n    this.iterations.push(iteration);\n\n    return {\n      emitter,\n      state: iteration.state,\n      meta,\n      signal: this.run.signal,\n    };\n  }\n\n  async init(input: ReActAgentRunInput) {\n    this.memory = await this.initMemory(input);\n  }\n\n  abstract llm(input: ReActAgentRunnerLLMInput): Promise<ReActAgentRunIteration>;\n\n  abstract tool(input: ReActAgentRunnerToolInput): Promise<{ output: string; success: boolean }>;\n\n  public abstract get defaultTemplates(): ReActAgentTemplates;\n\n  @Cache({ enumerable: false })\n  public get templates(): ReActAgentTemplates {\n    const overrides = this.input.templates ?? {};\n\n    return mapObj(this.defaultTemplates)(\n      (key, defaultTemplate: ReActAgentTemplates[typeof key]) => {\n        const override = overrides[key] ?? defaultTemplate;\n        if (override instanceof PromptTemplate) {\n          return override;\n        }\n        return override(defaultTemplate) ?? defaultTemplate;\n      },\n    );\n  }\n\n  protected abstract initMemory(input: ReActAgentRunInput): Promise<BaseMemory>;\n\n  createSnapshot() {\n    return {\n      input: shallowCopy(this.input),\n      options: shallowCopy(this.options),\n      memory: this.memory,\n      failedAttemptsCounter: this.failedAttemptsCounter,\n    };\n  }\n\n  loadSnapshot(snapshot: ReturnType<typeof this.createSnapshot>) {\n    Object.assign(this, snapshot);\n  }\n}\n"]}